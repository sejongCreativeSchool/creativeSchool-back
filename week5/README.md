## 로드 밸런서와 유저 인증

1. 로드 밸런서(Load Balancer)란?
2. 웹 인증 절차 ( Authentication )
3. 유저인증 방식 ( 쿠키 / 세션 / JWT )

### 1. 로드 밸런서(Load Balancer)란?

![a](https://nesoy.github.io/assets/posts/20180602/1.png)

지금까지 개발한 서버는 하나의 클라이언트와 서버가 통신한다고 가정함.

1:1의 상황이 지속된다면 문제가없지만 개발할 서비스는 1:n 의 요청을 수행해야하는 서버이기때문에 요청 기기가 늘어나면 서버에 무리가 갈 수 있음

이를 해결하기 위해서는 

- Scale-up : Server가 더 빠르게 동작하기 위해 하드웨어 성능을 올리는 방법.

- Scale-out : 하나의 Server 보다는 여러 대의 Server가 나눠서 일을 하는 방법.

두가지 방법이 있음. Scale-out 의 장점은 서버 한대 추가 비용이 덜 들고, 여러대의 컴퓨터로 인해서 무중단 서비스가 가능해진다.

![아](https://nesoy.github.io/assets/posts/20180602/3.png)

위와 같은 로드벨런싱의 종류로는 L2, L3, L4, L7 이 있음.

L2는 Mac주소를 바탕으로 나누는 것임

L3는 IP 주소를 바탕으로 나눈 것임

L3는 IP와 PORT 레벨에서 나눈것임 (UDP, TCP)

L7는 사용자의 Request 레벨에서 나눈것임 (HTTP, HTTPS, FTP)

### 2. 웹 인증 절차 ( Authentication )

거의 모든 사이트에 있는 로그인/회원가입 을 위해 인증은 꼭 필요한 절차임. 서버 사이드에서 받은 API 요청이 어떤 클라이언트에서 온 것인지 필수적으로 알아야함. 만약 알지 못한다면 유저의 정보가 타인에게 쉽게 넘어 가는 문제가 생기기 때문임

현재 웹에서 가장 많이 쓰이는 통신 방식은 HTTP임. HTTP는 비연결 지향이기때문에 연결 상태를 유지해주는 것이아니라 통신이 끝나면 연결을 끊어버림.
이러한 문제때문에 클라이언트와 서버사이의 통신이 끊어지게 되고 다른페이지를 요청했을 때 다시 인증을 확인해야하는 번거로움이 생김.

![ㅇ](https://t1.daumcdn.net/cfile/tistory/99E892345B53368707)

HTTP 통신은 위와같이 구성이 되어있음.

가장 최악의 인증방식으로는 HTTP 헤더 부분에 ID, PW 를 담아 보낼 수 있지만 언제든지 탈취될 수 있고 보낼 때 마다 인증해야하는 번거로움이 생긴다. 

이를 해결하기 위해 나온것이 쿠키, 세션, JWT 이다.

### 3. 유저인증 방식 ( 쿠키 / 세션 / JWT )

#### 1. 쿠키란?
쿠키는 클라이언트(유저의 컴퓨터)에 저장되는 텍스트 형식의 데이터를 말한다.
이 쿠키는 HTTP통신의 헤더에 자동으로 넣어서 전송된다

#### 2. 세션이란 ?

서버에 저장되는 정보를 의미합니다.

클라이언트에서 로그인 요청을 하면 서버의 세션저장소에 세션(로그인 기록)을 저장함
서버에서 세션 ID를 만들어서 클라이언트로 보내준다 (세션저장소가 '사물함'이면 세션ID가 '열쇠'라고 보면됨)
클라이언트에서는 이 세션ID를 쿠키에 담아둠.
페이지 이동시나 인증이 필요할 때마다 세션ID가 헤더에 담긴 HTTP요청을 서버로 보냄
서버가 세션ID로 세션저장소를 확인 후 적합하면 요청을 처리해줌

#### 3. JWT (토큰인증방식) 이란?

![ㅇ](https://t1.daumcdn.net/cfile/tistory/99329E345B53368603)

토큰을 만들기 위해서는 크게 3가지, Header,Payload, Verify Signature가 필요함
Header : 위 3가지 정보를 암호화할 방식(alg), 타입(type) 등이 들어감
Payload : 서버에서 보낼 데이터가 들어갑니다. 일반적으로 유저의 고유 ID값, 유효기간이 들어감
Verify Signature :  Base64 방식으로 인코딩한 Header,payload 그리고 SECRET KEY를 더한 후 서명됨

위와같은 형태로 토큰을 만들고

1. 사용자가 로그인을 함
2. 서버에서는 계정정보를 읽어 사용자를 확인 후, 사용자의 고유한 ID값을 부여한 후, 기타 정보와 함께 Payload에 넣음
3. JWT 토큰의 유효기간을 설정함
4. 암호화할 SECRET KEY를 이용해 ACCESS TOKEN을 발급함
5. 사용자는 Access Token을 받아 저장한 후, 인증이 필요한 요청마다 토큰을 헤더에 실어 보냄
6. 서버에서는 해당 토큰의 Verify Signature를 SECRET KEY로 복호화한 후, 조작 여부, 유효기간을 확인함
7. 검증이 완료된다면, Payload를 디코딩하여 사용자의 ID에 맞는 데이터를 가져옴.

위와같은 절차를 통해서 인증을 함.






